# ТЗ: Мультиязычность событий (RU/EN) для парсерных мероприятий

**Цель:** События, которые парсятся с русскоязычных источников (BaliForum и др.), должны отображаться на английском, если пользователь выбрал язык EN в боте.

---

## Контекст проекта (для агента)

- **Таблица событий:** `events` (модель `Event` в `database.py`). Сейчас есть колонки: `title`, `description`, `location_name` (все текстовые, без вариантов по языкам).
- **Парсинг и сохранение:** `utils/parser_integration.py` → `save_parser_events()` вызывает `UnifiedEventsService.save_parser_event()` в `utils/unified_events_service.py`. Данные приходят на русском.
- **Чтение событий:** `UnifiedEventsService.search_events_today()` в `utils/unified_events_service.py` — SELECT по `events`, возвращает список словарей с полями `title`, `description`, `location_name`. Эти словари используются в боте.
- **Вывод в боте:** В `bot_enhanced_v3.py` при формировании карточек событий используются `e.get("title")`, `e.get("description")`, `e.get("location_name")`. Язык пользователя: `get_user_language_or_default(user_id)` (уже есть в проекте). Нужно в этих местах подставлять английские поля, если `lang == "en"`.
- **Миграции:** лежат в `migrations/`, нумерация вида `039_...sql`. Создать новую миграцию для новых колонок.

---

## 1. Изменения в базе данных

- **Добавить колонки** в таблицу `events` (не переименовывать существующие):
  - `title_en` VARCHAR(255) NULL
  - `description_en` TEXT NULL  
  - `location_name_en` VARCHAR(255) NULL  

- **Семантика:** Текущие `title`, `description`, `location_name` считаем русскими (как есть). Поля `_en` — перевод для отображения при выборе английского.

- **Обновить модель** `Event` в `database.py`: добавить поля `title_en`, `description_en`, `location_name_en` (nullable).

- **Миграция:** один SQL-файл в `migrations/` (например `040_add_events_title_description_location_en.sql`) с `ALTER TABLE events ADD COLUMN ...`. Без изменения существующих данных.

---

## 2. Перевод через OpenAI (gpt-4o-mini)

- **Модель:** `gpt-4o-mini` (дешевле и быстрее).
- **Системный промпт:**  
  «Ты — профессиональный переводчик афиши мероприятий на Бали. Переводи текст с русского на английский, сохраняя культурный контекст (йога, духовные практики, вечеринки). Названия заведений и брендов оставляй на латинице. Если название — это имя собственное игры или практики (например, "Изобилие", "Лила"), лучше писать транслитерацию и перевод в скобках, например: "Izobilie (Abundance)". Названия локаций только на латинице (например Red Ruby). Возвращай только перевод, без пояснений.»

- **Функция перевода:** создать или вынести в утилиту (например `utils/event_translation.py`):
  - Вход: строка(и) для перевода (title, description, location_name).
  - Выход: словарь `{"title_en": "...", "description_en": "...", "location_name_en": "..."}` или по одному полю.
  - **Обработка ошибок:** при любой ошибке (API недоступен, лимит, таймаут) не падать, а возвращать пустые значения или копию оригинала для `_en`. Логировать ошибку. Парсер не должен ломаться из‑за сбоя перевода.

- **Конфиг:** использовать существующий ключ OpenAI из проекта (проверить `config.py` / переменные окружения). Если ключа нет — перевод не вызывать, сохранять только русские поля.

---

## 3. Логика парсинга и сохранения

- **Где вызывать перевод:** один раз при сохранении парсерного события — в момент вызова `save_parser_event()` (внутри него или в `utils/parser_integration.py` перед вызовом).
- **Последовательность:**
  1. Парсер отдаёт событие (RU): title, description, location_name.
  2. Перед записью в БД вызвать функцию перевода для этих полей.
  3. В БД сохранять сразу и русские поля (title, description, location_name), и английские (title_en, description_en, location_name_en). Если перевод не удался — сохранять только русские, `_en` оставить NULL (или при желании скопировать туда оригинал как fallback).
- **Обновление существующих записей (ON CONFLICT / UPDATE):** при обновлении по `(source, external_id)` переводить заново только если изменился текст (title или description). Если текст не изменился — не вызывать API, не перезаписывать `_en`. Это оптимизация, чтобы не тратить токены на повторный перевод без изменений.

---

## 4. Вывод в Telegram-боте

- **Правило выбора текста:**  
  Если у пользователя язык `en` — брать для отображения `title_en` / `description_en` / `location_name_en`.  
  Если поле `_en` пустое (NULL) — использовать русское поле как fallback.

- **Где менять код:** везде, где по событию из `search_events_today` формируется сообщение пользователю:
  - Функция/блок, собирающий текст карточки события (например `render_event_html` или аналог в `bot_enhanced_v3.py`), должен получать язык пользователя и выбирать:
    - `display_title = (event.get("title_en") or event.get("title") or "").strip() or "—"`
    - `display_description = event.get("description_en") or event.get("description") or ""`
    - `display_location_name = event.get("location_name_en") or event.get("location_name") or ""`
  - Аналогично для любого другого места, где выводятся title/description/location_name события (списки, превью, пагинация и т.д.).

- **Чтение из БД:** в `UnifiedEventsService.search_events_today()` в SELECT добавить колонки `title_en`, `description_en`, `location_name_en` и включать их в возвращаемые словари событий, чтобы бот мог использовать их при формировании сообщений.

---

## 5. Миграция существующих событий (backfill)

- **Скрипт (один раз):** например `scripts/backfill_events_translations.py` или отдельная команда.
- **Логика:**
  - Выбрать из `events` записи, где источник парсерный (например `source IN ('baliforum', 'kudago', 'ai')`) и `title_en IS NULL` (ещё не переведены).
  - Обрабатывать батчами (например по 10–20 записей), чтобы не перегружать API.
  - Для каждой записи: взять `title`, `description`, `location_name`, вызвать функцию перевода, обновить `title_en`, `description_en`, `location_name_en`.
  - При ошибке API для записи: залогировать, оставить `_en` NULL, перейти к следующей записи (скрипт не падать).
- **Запуск:** вручную или по инструкции в README. Не блокировать деплой.

---

## 6. Что нужно от агента Cursor

1. **Проанализировать** модель `Event` в `database.py`, метод `save_parser_event` в `utils/unified_events_service.py`, вызовы из `utils/parser_integration.py` и места в `bot_enhanced_v3.py`, где выводятся title/description/location_name события.
2. **Предложить конкретные правки:**
   - миграция SQL для колонок `title_en`, `description_en`, `location_name_en`;
   - обновление модели `Event`;
   - утилита перевода с обработкой ошибок;
   - вызов перевода при сохранении парсерного события (и условие «не переводить при update, если текст не изменился»);
   - расширение SELECT в `search_events_today` и словарей событий;
   - подстановка по языку при формировании сообщений в боте.
3. **Написать скрипт миграции** (backfill) для перевода уже существующих событий в БД.
4. **Убедиться:** при сбое OpenAI парсер и сохранение событий не падают; в боте при пустом `_en` используется русский текст (fallback).

---

## Важно по ошибкам API

Если OpenAI недоступен, закончились токены или произошла сетевая ошибка:
- парсер должен сохранить событие с заполненными только русскими полями (`title`, `description`, `location_name`);
- поля `title_en`, `description_en`, `location_name_en` оставить NULL (или при желании скопировать туда оригинал);
- ошибку залогировать, не пробрасывать исключение наверх, чтобы не ломать весь пайплайн парсинга.
